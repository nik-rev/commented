//! Fetch the helix's `languages.toml` file, and generate Rust code
//! for the `comment_line` using the data in the file

mod helix_languages_toml;

use std::{error::Error, fs, path::Path};

use helix_languages_toml::FileType;
use itertools::Itertools as _;
use quote::quote;
use tap::Pipe as _;

/// File to fetch
const FILE: &str = "https://raw.githubusercontent.com/helix-editor/helix/479c3b55847eae060b69e6f0eda0bd95d93a7fa0/languages.toml";

#[allow(
    clippy::print_stdout,
    clippy::print_stderr,
    reason = "print is allowed from `main`"
)]
fn main() -> Result<(), Box<dyn Error>> {
    let config = ureq::get(FILE)
        .call()?
        .body_mut()
        .read_to_string()?
        .pipe(|s| toml::de::from_str::<helix_languages_toml::HelixLanguagesToml>(&s))?;

    let if_conditions_for_each_file_type = config
        .language
        .iter()
        .sorted_by(|a, b| a.name.cmp(&b.name))
        .filter_map(|lang| {
            let (start_token, end_token) = if let Some(block_comment_tokens) =
                &lang.block_comment_tokens
                && let Some(block_comment_token) = block_comment_tokens.first()
            {
                (
                    block_comment_token.start.clone(),
                    block_comment_token.end.clone(),
                )
            } else if let Some(comment_tokens) = &lang.comment_tokens
                && let Some(comment_token) = comment_tokens.first()
            {
                (comment_token.clone(), String::new())
            } else {
                return None;
            };

            lang.file_types
                .iter()
                .map(move |file_type| {
                    match file_type {
                        FileType::Extension(ext) => quote! {
                            extension.is_some_and(|ext| ext == #ext)
                        },
                        // TODO: handle globs
                        FileType::Glob(glob) => {
                            let glob = glob.glob();

                            quote! {{
                                #[cfg(feature = "glob")]
                                let glob = globset::Glob::new(#glob).expect(concat!(
                                    "deserialization would fail in the ",
                                    "build script if this glob was invalid"
                                )).compile_matcher().is_match(path);
                                #[cfg(not(feature = "glob"))]
                                let glob = false;

                                glob
                            }}
                        }
                    }
                    .pipe(|matches_filetype| {
                        (
                            quote! {
                                if #matches_filetype {
                                    (#start_token, #end_token)
                                }
                            },
                            match file_type {
                                FileType::Glob(_) => true,
                                FileType::Extension(_) => false,
                            },
                        )
                    })
                })
                .pipe(Some)
        })
        .flatten()
        .sorted_by_key(|(_, is_glob)| *is_glob)
        .map(|(tokens, _)| tokens);

    let tokens = quote! {

        use std::path::Path;

        #[rustfmt::skip]
        #[allow(warnings, clippy::ifs_same_cond, reason = "this function is generated by a script")]
        pub(super) fn comment<S: ToString, P: AsRef<Path>>(content: S, path: P) -> String {
            let path: &Path = path.as_ref();
            let extension = path.extension();

            let (start_token, end_token) = #(#if_conditions_for_each_file_type)else* else {
                // this is the default fallback for when no filetype is detected
                ("#", "")
            };

            let content = content.to_string();

            let mut buf = String::with_capacity(start_token.len() + content.len() + end_token.len() + 2);
            buf.push_str(start_token);
            if !start_token.is_empty() {
                buf.push(' ');
            }
            buf.push_str(&content);
            if !end_token.is_empty() {
                buf.push(' ');
            }
            buf.push_str(end_token);
            buf
        }
    };

    let formatted = tokens
        .to_string()
        .pipe_deref(syn::parse_file)?
        .pipe_ref(prettyplease::unparse);

    let out = Path::new(env!("CARGO_MANIFEST_DIR"))
        .join("..")
        .join("src")
        .join("generated.rs");

    fs::write(&out, formatted)
        .map_err(|err| format!("failed to write final output to {}: {err}", out.display()))?;

    Ok(())
}
